
# C2 线程管控
## 2.1 线程的基本管控
### 2.1.1 发起线程

-  任何可调用类型（callable type）都适用于std::thread（具体包括：函数指针、函数对象、lambda等）

-  解决C++解释函数与线程构造的问题，做法是多用一对圆括号，或采用新式的统一初始化语法（uniform initialization syntax，又名列表初始化）

-  一旦启动了线程，我们就需明确是要等待它结束（与之汇合，见2.1.2节），还是任由它独自运行（与之分离，见2.1.3节）。假如等到std::thread对象销毁之际还没决定好，那std::thread的析构函数将调用std::terminate()终止整个程序

-  如果选择了分离，且分离时新线程还未结束运行，那它将继续运行，甚至在std::thread对象销毁很久之后依然运行，它只有最终从线程函数返回时才会结束运行。

-  假定程序不等待线程结束，那么在线程运行结束前，我们需保证它所访问的外部数据始终正确、有效。

### 2.1.2 等待线程完成

-  若需等待线程完成，那么可以在与之关联的std::thread实例上，通过调用成员函数join()实现。

-  对于某个给定的线程，join()仅能调用一次；只要std::thread对象曾经调用过join()，线程就不再可汇合（joinable），成员函数joinable()将返回false。
### 2.1.3 在出现异常的情况下等待
- 如果在线程启动之后，join调用之前发生了异常，将无法正常等待线程结束。可以利用异常捕捉（try/catch）的方式来调用join，或者利用RAII手法，在析构函数中调用

### 2.1.4 在后台运行线程

-  分离的线程确实仍在后台运行，其归属权和控制权都转移给C++运行时库（runtime library，又名运行库），由此保证，一旦线程退出，与之关联的资源都会被正确回收。

-  只有当t.joinable()返回true时，我们才能调用t.detach()。

## 2.2 向线程函数传递参数

-  线程具有内部存储空间，参数会按照默认方式先复制到该处，新创建的执行线程才能直接访问它们。然后，这些副本被当成临时变量，以右值形式传给新线程上的函数或可调用对象。即便函数的相关参数按设想应该是引用，上述过程依然会发生。

-  若要将某个类的成员函数设定为线程函数，我们则应传入一个函数指针，指向该成员函数。此外，我们还要给出合适的对象指针，作为该函数的第一个参数

-  C++11还引入了另一种传递参数的方式：参数只能移动但不能复制，即数据从某个对象转移到另一个对象内部，而原对象则被“搬空”
