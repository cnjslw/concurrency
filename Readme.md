# C2 线程管控
## 2.1 线程的基本管控
### 2.1.1 发起线程

-  任何可调用类型（callable type）都适用于std::thread（具体包括：函数指针、函数对象、lambda等）

-  解决C++解释函数与线程构造的问题，做法是多用一对圆括号，或采用新式的统一初始化语法（uniform initialization syntax，又名列表初始化）

-  一旦启动了线程，我们就需明确是要等待它结束（与之汇合，见2.1.2节），还是任由它独自运行（与之分离，见2.1.3节）。假如等到std::thread对象销毁之际还没决定好，那std::thread的析构函数将调用std::terminate()终止整个程序

-  如果选择了分离，且分离时新线程还未结束运行，那它将继续运行，甚至在std::thread对象销毁很久之后依然运行，它只有最终从线程函数返回时才会结束运行。

-  假定程序不等待线程结束，那么在线程运行结束前，我们需保证它所访问的外部数据始终正确、有效。

### 2.1.2 等待线程完成

-  若需等待线程完成，那么可以在与之关联的std::thread实例上，通过调用成员函数join()实现。

-  对于某个给定的线程，join()仅能调用一次；只要std::thread对象曾经调用过join()，线程就不再可汇合（joinable），成员函数joinable()将返回false。
### 2.1.3 在出现异常的情况下等待
- 如果在线程启动之后，join调用之前发生了异常，将无法正常等待线程结束。可以利用异常捕捉（try/catch）的方式来调用join，或者利用RAII手法，在析构函数中调用

### 2.1.4 在后台运行线程

-  分离的线程确实仍在后台运行，其归属权和控制权都转移给C++运行时库（runtime library，又名运行库），由此保证，一旦线程退出，与之关联的资源都会被正确回收。

-  只有当t.joinable()返回true时，我们才能调用t.detach()。

## 2.2 向线程函数传递参数

-  线程具有内部存储空间，参数会按照默认方式先复制到该处，新创建的执行线程才能直接访问它们。然后，这些副本被当成临时变量，以右值形式传给新线程上的函数或可调用对象。即便函数的相关参数按设想应该是引用，上述过程依然会发生。

- 如果参数是指针，并且指向自动变量，就可能发生还没有来得及转换完成，自动变量就析构掉的问题

    ```cpp
    void f(int i , std::string const& s);
    int main()
    {
        char buffer[26];
        //std::thread t(f,3,buffer);
        std::thread t(f,3,std::string(buffer));
        t.detach();
    }
    ```
    请注意，尽管函数f()的第二个参数属于std::string类型，但字符串的字面内容仍以指针char const*的形式传入，进入新线程的上下文环境以后，才转换为std::string类型,
    我们本来希望将指针buffer隐式转换成std::string对象，再将其用作函数参数，可惜转换未能及时发生，原因是std::thread的构造函数原样复制所提供的值，并未令其转换为预期的参数类型。解决方法是，在buffer传入std::thread的构造函数之前，就把它转化成std::string对象

- 若需按引用方式传递参数，只要用std::ref()函数加以包装即可

- 若要将某个类的成员函数设定为线程函数，我们则应传入一个函数指针，指向该成员函数。此外，我们还要给出合适的对象指针，作为该函数的第一个参数

-  C++11还引入了另一种传递参数的方式：参数只能移动但不能复制，即数据从某个对象转移到另一个对象内部，而原对象则被“搬空”，比如std::unique_ptr,临时变量，具名对象但是使用std::move()

## 2.3 移交线程归属权
- 假设要编写函数，功能是创建线程，并置于后台运行，但该函数本身不等待线程完结，而是将其归属权向上移交给函数的调用者；或相反地，读者想创建线程，遂将其归属权传入某个函数，由它负责等待该线程结束。两种操作都需要转移线程的归属权。这正是std::thread支持移动语义的缘由。

- 因为是临时变量，所以无须显式调用std::move()，因为新线程本来就由临时变量持有，而源自临时变量的移动操作会自动地隐式进行。

- 只要std::thread对象正管控着一个线程，就不能简单地向它赋新值，否则该线程会因此被遗弃。

- std::thread支持移动操作的意义是，函数可以便捷地向外部转移线程的归属权

## 2.4　在运行时选择线程数量
std::thread::hardware_concurrency()函数，它的返回值是一个指标，表示程序在各次运行中可真正并发的线程数量

## 2.5 识别线程

# C3 在线程间共享数据

## 3.1 线程间共享数据的问题
- 归根结底，多线程共享数据的问题多由数据改动引发。如果所有共享数据都是只读数据，就不会有问题。

### 3.1.1 条件竞争
“数据竞争”（data race）：并发改动单个对象而形成的特定的条件竞争

### 3.1.2 防止恶性条件竞争
- 最简单的就是采取保护措施包装数据结构，确保不变量被破坏时，中间状态只对执行改动的线程可见

- 另一种方法是，修改数据结构的设计及其不变量，由一连串不可拆分的改动完成数据变更，每个改动都维持不变量不被破坏。这通常被称为无锁编程，难以正确编写。

- 将修改数据结构当作事务（transaction）来处理

## 3.2 用互斥保护共享数据
### 3.2.1 在C++中使用互斥
- C++标准库提供了类模板`std::lock_guard<>`，针对互斥类融合实现了RAII手法：在构造时给互斥加锁，在析构时解锁，从而保证互斥总被正确解锁。

- C++17引入了一个新特性，名为类模板参数推导（class template argument deduction），顾名思义，对于`std::lock_guard<>`这种简单的类模板，模板参数列表可以忽略。简化成`std::lock_guard guard(some_mutex);`

- 可惜事与愿违，敏锐的读者可能已经注意到，如果成员函数返回指针或引用，指向受保护的共享数据，那么即便成员函数全都按良好、有序的方式锁定互斥，仍然无济于事，因为保护已被打破，出现了大漏洞。只要存在任何能访问该指针和引用的代码，它就可以访问受保护的共享数据（也可以修改），而无须锁定互斥。

### 3.2.2　组织和编排代码以保护共享数据
- 既要检查成员函数，防止向调用者传出指针或引用，也要检查若成员函数在自身内部调用了别的函数，而这些函数却不受我们掌控，那么，也不得向它们传递这些指针或引用。

- 不得向锁所在的作用域之外传递指针和引用，指向受保护的共享数据，无论是通过函数返回值将它们保存到对外可见的内存，还是将它们作为参数传递给使用者提供的

### 3.2.3 发现接口固有的条件竞争
从栈容器类的一个成员方法的接口中分析接口固有的条件竞争问题：
```cpp
stack<int> s ;
if(!empty())
{
    int const value =s.top();//①
    s.pop();//②
    do_something(value);
}
```
- 情况1：线程1运行①后，即将运行②，但是线程2此时调用了pop(),线程1此时调用pop()出错
- 情况2：两个线程交替运行①②，线程1运行完①之后，线程2运行①，随后依次pop(),这就造成了，线程1、2获取的栈顶元素都是同一个，但是原本栈顶下一个元素、本应该是线程2获取的栈顶元素，却被直接抛弃了。
- 解决方案1：将pop()和top()组合成一个成员函数，再采取互斥保护成员函数互斥调用

- 新的情况：top()和pop()的组个函数是需要调用拷贝构造函数后再删除栈顶函数，如果复制的过程中异常，但是栈顶元素已经被删除了，造成了数据的丢失
- 新的解决方案1：传入引用
- 新的解决方案2：提供不抛出异常的拷贝构造函数，或不抛出异常的移动构造函数
- 新的解决方案3：返回指针，指向弹出的元素


## 3.2.4 死锁和解决方法
防范死锁的建议通常是，始终按相同顺序对两个互斥加锁。然而，在某些情况下，采取固定的加锁顺序可能会导致死锁问题。例如，当多个互斥量用于保护类的不同实例时，如果一个函数需要操作两个实例并且固定了它们的加锁顺序，那么在多线程环境下，可能会出现死锁问题。
例如：假设有两个账户A和B，它们都有对应的余额和互斥量mutexA和mutexB。现在需要编写一个函数transfer，用于将账户A的余额转移到账户B中。为了保证并发修改的正确性，必须对两个账户的互斥量分别进行加锁。
```cpp
#include <thread>
#include <mutex>

class Account {
public:
    void transferTo(Account& other, double amount) {
        std::lock_guard<std::mutex> lock1(mutex);
        std::lock_guard<std::mutex> lock2(other.mutex);
        
        // 将余额从当前账户转移到另一个账户中
        balance -= amount;
        other.balance += amount;
    }
    
private:
    std::mutex mutex;
    double balance;
};

int main()
{
    Account accountA, accountB;
    accountA.transferTo(accountB, 100.0); // 线程1执行该语句
    accountB.transferTo(accountA, 200.0); // 线程2执行该语句
    
    return 0;
}

```
此时就会造成死锁！

- C++标准库提供了std::lock()函数，专门解决上述问题。它可以同时锁住多个互斥，而没有发生死锁的风险。还提供了std::adopt_lock对象，以指明互斥已被锁住，即互斥上有锁存在，std::lock_guard实例应当据此接收锁的归属权，不得在构造函数内试图另行加锁。

- 原理：假如std::lock()函数在其中一个互斥上成功获取了锁，但它试图在另一个互斥上获取锁时却有异常抛出，那么第一个锁就会自动释放：若加锁操作涉及多个互斥，则std::lock()函数的语义是“全员共同成败”（all-or-nothing，或全部成功锁定，或没获取任何锁并抛出异常）。

- C++17还进一步提供了新的RAII类模板std::scoped_lock<>。std:: scoped_lock<>和std::lock_guard<>完全等价，只不过前者是可变参数模板（variadic template），接收各种互斥型别作为模板参数列表，还以多个互斥对象作为构造函数的参数列表。

## 3.2.5 防范死锁的补充准则
1. 避免嵌套锁
第一条准则最简单：假如已经持有锁，就不要试图获取第二个锁

<br>

2. 一旦持锁，就须避免调用由用户提供的程序接口

<br>

若程序接口由用户自行实现，则我们无从得知它到底会做什么，它可能会随意操作，包括试图获取锁

3. 依从固定顺序获取锁

<br>

4. 按层级加锁

<br>

5. 将准则推广到锁操作以外
