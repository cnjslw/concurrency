
# C2 线程管控
## 2.1 线程的基本管控
### 2.1.1 发起线程

-  任何可调用类型（callable type）都适用于std::thread（具体包括：函数指针、函数对象、lambda等）

-  解决C++解释函数与线程构造的问题，做法是多用一对圆括号，或采用新式的统一初始化语法（uniform initialization syntax，又名列表初始化）

-  一旦启动了线程，我们就需明确是要等待它结束（与之汇合，见2.1.2节），还是任由它独自运行（与之分离，见2.1.3节）。假如等到std::thread对象销毁之际还没决定好，那std::thread的析构函数将调用std::terminate()终止整个程序

-  如果选择了分离，且分离时新线程还未结束运行，那它将继续运行，甚至在std::thread对象销毁很久之后依然运行，它只有最终从线程函数返回时才会结束运行。

-  假定程序不等待线程结束，那么在线程运行结束前，我们需保证它所访问的外部数据始终正确、有效。

### 2.1.2 等待线程完成

-  若需等待线程完成，那么可以在与之关联的std::thread实例上，通过调用成员函数join()实现。

-  对于某个给定的线程，join()仅能调用一次；只要std::thread对象曾经调用过join()，线程就不再可汇合（joinable），成员函数joinable()将返回false。
### 2.1.3 在出现异常的情况下等待
- 如果在线程启动之后，join调用之前发生了异常，将无法正常等待线程结束。可以利用异常捕捉（try/catch）的方式来调用join，或者利用RAII手法，在析构函数中调用

### 2.1.4 在后台运行线程

-  分离的线程确实仍在后台运行，其归属权和控制权都转移给C++运行时库（runtime library，又名运行库），由此保证，一旦线程退出，与之关联的资源都会被正确回收。

-  只有当t.joinable()返回true时，我们才能调用t.detach()。

## 2.2 向线程函数传递参数

-  线程具有内部存储空间，参数会按照默认方式先复制到该处，新创建的执行线程才能直接访问它们。然后，这些副本被当成临时变量，以右值形式传给新线程上的函数或可调用对象。即便函数的相关参数按设想应该是引用，上述过程依然会发生。

- 如果参数是指针，并且指向自动变量，就可能发生还没有来得及转换完成，自动变量就析构掉的问题

    ```cpp
    void f(int i , std::string const& s);
    int main()
    {
        char buffer[26];
        //std::thread t(f,3,buffer);
        std::thread t(f,3,std::string(buffer));
        t.detach();
    }
    ```
    请注意，尽管函数f()的第二个参数属于std::string类型，但字符串的字面内容仍以指针char const*的形式传入，进入新线程的上下文环境以后，才转换为std::string类型,
    我们本来希望将指针buffer隐式转换成std::string对象，再将其用作函数参数，可惜转换未能及时发生，原因是std::thread的构造函数原样复制所提供的值，并未令其转换为预期的参数类型。解决方法是，在buffer传入std::thread的构造函数之前，就把它转化成std::string对象

- 若需按引用方式传递参数，只要用std::ref()函数加以包装即可

- 若要将某个类的成员函数设定为线程函数，我们则应传入一个函数指针，指向该成员函数。此外，我们还要给出合适的对象指针，作为该函数的第一个参数

-  C++11还引入了另一种传递参数的方式：参数只能移动但不能复制，即数据从某个对象转移到另一个对象内部，而原对象则被“搬空”，比如std::unique_ptr,临时变量，具名对象但是使用std::move()

## 2.3 移交线程归属权
- 假设要编写函数，功能是创建线程，并置于后台运行，但该函数本身不等待线程完结，而是将其归属权向上移交给函数的调用者；或相反地，读者想创建线程，遂将其归属权传入某个函数，由它负责等待该线程结束。两种操作都需要转移线程的归属权。这正是std::thread支持移动语义的缘由。

- 因为是临时变量，所以无须显式调用std::move()，因为新线程本来就由临时变量持有，而源自临时变量的移动操作会自动地隐式进行。

- 只要std::thread对象正管控着一个线程，就不能简单地向它赋新值，否则该线程会因此被遗弃。

- std::thread支持移动操作的意义是，函数可以便捷地向外部转移线程的归属权

## 2.4　在运行时选择线程数量
std::thread::hardware_concurrency()函数，它的返回值是一个指标，表示程序在各次运行中可真正并发的线程数量

## 2.5 识别线程
